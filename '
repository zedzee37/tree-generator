import math 


class KdNode:
    def __init__(self, point):
        self.point = point
        self.left = None
        self.right = None


class StaticKdTree:
    def __init__(self, points, k):
        self.head = None
        self.k = k

        self.head = self._build_tree(points, 0)

    def _build_tree(self, points, depth):
        if len(points) == 0:
            return None

        axis = depth % self.k 
        
        pts_sorted = sorted(points, key=lambda pt: pt[axis])

        median_idx = len(pts_sorted) // 2
        median_pt = pts_sorted[median_idx]

        node = KdNode(median_pt)

        node.left = self._build_tree(
            points[:median_idx],
            depth + 1
        ) 
        node.right = self._build_tree(
            points[median_idx + 1:],
            depth + 1
        ) 
        
        return node

    def nearest_neighbor(self, point):
        def distance_squared(p1, p2, k):
            distance_sqrd = 0

            for i in range(k):
                distance_sqrd += p1[i]**2
                distance_sqrd += p2[i]**2
            
            return distance_sqrd
        

        def distance(p1, p2, k):
            return math.sqrt(distance_squared(p1, p2, k))


        def recurse(depth, node, best):
            axis = depth % self.k

            has_left = node.left is not None
            has_right = node.right is not None

            if not has_left:
                return best

        
        return recurse(0, self.head, self.head)


import random as rand

rand.seed(0)
random_points = []
for i in range(100):
    random_points.append((rand.randint(0, 100), rand.randint(0, 100)))

tree = StaticKdTree(random_points, 2)
